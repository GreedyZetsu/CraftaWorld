getgenv().StartatY = 7
getgenv().EndatY = 37

if _G.FarmerRunning then return end
_G.FarmerRunning = true

-- [[ INTERNAL CONFIGURATION ]] --
local PlaceY = {}
-- We step by 3 to cover the character's reach (offset -1, 0, 1)
for y = getgenv().StartatY, getgenv().EndatY, 3 do table.insert(PlaceY, y) end

local TILE_SIZE = 4.5
local MOVE_SPEED = 38 -- Optimized speed for block clearing
local settings = { Enabled = true, VerifyRetries = 2 }

-- [[ MODULES ]] --
local rs = game:GetService("ReplicatedStorage")
local run = game:GetService("RunService")
local lplr = game.Players.LocalPlayer
local WorldTilesData = require(rs:WaitForChild("WorldTiles"))
local movement = require(lplr.PlayerScripts:WaitForChild("PlayerMovement"))
local fistRemote = rs.Remotes.PlayerFist

-- [[ PHYSICS FREEZE ]] --
run.Heartbeat:Connect(function()
    if not settings.Enabled then return end
    movement.MoveX = 0 
    if not movement.Grounded or math.abs(movement.VelocityY) > 0 then
        movement.VelocityY = 0; movement.VelocityX = 0
        movement.Position = Vector3.new(movement.Position.X, movement.Position.Y, 0)
    end
end)

-- [[ UTILITIES ]] --
local function Format3Dto2D(pos) return math.round(pos / TILE_SIZE) end

local function walkToGrid(targetX, targetY)
    local targetPos = Vector3.new(targetX * TILE_SIZE, targetY * TILE_SIZE, 0)
    while settings.Enabled do
        local currentPos = movement.Position
        local distance = (targetPos - currentPos).Magnitude
        if distance < 0.1 then movement.Position = targetPos break end
        movement.Position = currentPos + ((targetPos - currentPos).Unit * math.min(distance, MOVE_SPEED * task.wait()))
    end
end

-- Checks if Index 1 or Index 2 is occupied by any tile
local function isOccupied(x, y)
    local cell = WorldTilesData[x] and WorldTilesData[x][y]
    if not cell then return false end
    -- Return true if either Foreground (1) or Background (2) has data
    return (cell[1] ~= nil or cell[2] ~= nil)
end

-- Clears both layers at a specific coordinate
local function clearTile(tx, ty)
    for layer = 1, 2 do
        local retries = 0
        -- Check if that specific layer has a block
        while WorldTilesData[tx] and WorldTilesData[tx][ty] and WorldTilesData[tx][ty][layer] and retries < settings.VerifyRetries do
            fistRemote:FireServer(Vector2.new(tx, ty), layer)
            task.wait(0.07) -- Fast remote firing for instant blocks
            retries = retries + 1
        end
    end
end

-- Scans the 3x3 area (Character = 0, Surroundings = 1 and -1)
local function work3x3(charX, charY)
    for offsetX = -1, 1 do
        for offsetY = -1, 1 do
            local tx, ty = charX + offsetX, charY + offsetY
            if isOccupied(tx, ty) then
                clearTile(tx, ty)
            end
        end
    end
end

-- [[ MAIN EXECUTION ]] --
task.spawn(function()
    print("Dirt DF Clearer Active: Index 1 & 2")

    -- PHASE 1: Left Drop Clear (Covers X 0, 1, 2)
    for y = getgenv().EndatY, 7, -3 do
        walkToGrid(1, y) 
        work3x3(1, y)
    end

    -- PHASE 2: Right Drop Clear (Covers X 97, 98, 99)
    for y = getgenv().EndatY, 7, -3 do
        walkToGrid(98, y)
        work3x3(98, y)
    end

    -- PHASE 3: Main Farm Snake Pattern (3x3 stations)
    while true do
        for _, targetY in ipairs(PlaceY) do
            local currentX = Format3Dto2D(movement.Position.X)
            local startX = (currentX < 50) and 2 or 97
            local endX = (startX == 2) and 97 or 2
            local step = (startX == 2) and 3 or -3 

            for xStation = startX, endX, step do
                if not settings.Enabled then break end
                
                -- Optimization: Only walk to the station if there's something to break in the 3x3 area
                local hasBlocks = false
                for ox = -1, 1 do
                    for oy = -1, 1 do
                        if isOccupied(xStation + ox, targetY + oy) then
                            hasBlocks = true; break
                        end
                    end
                end

                if hasBlocks then
                    walkToGrid(xStation, targetY)
                    work3x3(xStation, targetY)
                end
            end
        end
        task.wait(0.5)
    end
end)
